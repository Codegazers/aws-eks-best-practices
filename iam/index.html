<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>Identity and Access Management - EKS Security Best Practices</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.1, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href=".." target="_blank" class="custom-link">EKS Security Best Practices</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="">
<a href="..">Home</a>
<li class="chapter active" data-path="iam/">
<a href="./">Identity and Access Management</a>
<li class="chapter" data-path="pods/">
<a href="../pods/">Pod Security</a>
<li class="chapter" data-path="multitenancy/">
<a href="../multitenancy/">Multi-tenancy</a>
<li class="chapter" data-path="detective/">
<a href="../detective/">Detective Controls</a>
<li class="chapter" data-path="network/">
<a href="../network/">Network Security</a>
<li class="chapter" data-path="data/">
<a href="../data/">Data Encryption and Secrets Management</a>
<li class="chapter" data-path="runtime/">
<a href="../runtime/">Runtime Security</a>
<li class="chapter" data-path="hosts/">
<a href="../hosts/">Infrastructure Security</a>
<li class="chapter" data-path="compliance/">
<a href="../compliance/">Regulatory Compliance</a>
<li class="chapter" data-path="incidents/">
<a href="../incidents/">Incident Response and Forensics</a>
<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h1 id="identity-and-access-management">Identity and Access Management<a class="headerlink" href="#identity-and-access-management" title="Permanent link">&para;</a></h1>
<p>Identity and Access Management (IAM) is an AWS service that performs 2 essential functions: Authentication and Authorization.  Authentication involves the verification of a indentity whereas authorization governs the actions that can be performed by AWS resources.  Within AWS, a resource can be another AWS service, e.g. EC2, or an AWS principle such as an IAM User or Role.  The rules governing the actions that a resource is allowed to peform are expressed as IAM policies.  </p>
<h2 id="controlling-access-to-eks-clusters">Controlling Access to EKS Clusters<a class="headerlink" href="#controlling-access-to-eks-clusters" title="Permanent link">&para;</a></h2>
<p>The Kubernetes project supports a variety of different strategies to authenticate requests to the kube-apiserver service, e.g. Bearer Tokens, X.509 certificates, OIDC, etc. EKS currently has native support for <a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication">webhook token authentication</a> and <a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#service-account-tokens">serivce account tokens</a>.  </p>
<p>The webhook authentication strategy calls a webhook that verifies bearer tokens. On EKS, these bearer tokens are generated by the AWS CLI or the <a href="https://github.com/kubernetes-sigs/aws-iam-authenticator">aws-iam-authenticator</a> client when you run <code>kubectl</code> commands. As you execute commands, the token is passed to the kube-apiserver which forwards it to the authentication webhook.  If the request is well-formed, the webhook calls a pre-signed URL embedded in the token's body. This URL validates the request's signature and returns information about the user, e.g. the user's account, Arn, and UserId to the kube-apiserver.  </p>
<p>To generate a authentication token, type the following command in a terminal window: </p>
<pre><code>aws eks get-token --cluster &lt;cluster_name&gt;
</code></pre>

<p>The output should resemble this: </p>
<pre><code class="json">{&quot;kind&quot;: &quot;ExecCredential&quot;, &quot;apiVersion&quot;: &quot;client.authentication.k8s.io/v1alpha1&quot;, &quot;spec&quot;: {}, &quot;status&quot;: {&quot;expirationTimestamp&quot;: &quot;2020-02-19T16:08:27Z&quot;, &quot;token&quot;: &quot;k8s-aws-v1.aHR0cHM6Ly9zdHMuYW1hem9uYXdzLmNvbS8_QWN0aW9uPUdldENhbGxlcklkZW50aXR5JlZlcnNpb249MjAxMS0wNi0xNSZYLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFKTkdSSUxLTlNSQzJXNVFBJTJGMjAyMDAyMTklMkZ1cy1lYXN0LTElMkZzdHMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDIwMDIxOVQxNTU0MjdaJlgtQW16LUV4cGlyZXM9NjAmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0JTNCeC1rOHMtYXdzLWlkJlgtQW16LVNpZ25hdHVyZT0yMjBmOGYzNTg1ZTMyMGRkYjVlNjgzYTVjOWE0MDUzMDFhZDc2NTQ2ZjI0ZjI4MTExZmRhZDA5Y2Y2NDhhMzkz&quot;}}
</code></pre>

<p>Each token starts with <code>k8s-aws-v1.</code> followed by a base64 encoded string. The string, when decoded, should resemble this: </p>
<pre><code>https://sts.amazonaws.com/?Action=GetCallerIdentity&amp;Version=2011-06-15&amp;X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAJNGRILKNSRC2W5QA%2F20200219%2Fus-east-1%2Fsts%2Faws4_request&amp;X-Amz-Date=20200219T155427Z&amp;X-Amz-Expires=60&amp;X-Amz-SignedHeaders=host%3Bx-k8s-aws-id&amp;X-Amz-Signature=220f8f3585e320ddb5e683a5c9a405301ad76546f24f28111fdad09cf648a393
</code></pre>

<p>The token consists of a pre-signed URL that includes an Amazon credential and signature. For additional see https://docs.aws.amazon.com/STS/latest/APIReference/API_GetCallerIdentity.html. </p>
<p>The token has a time to live (TTL) of 15 minutes after which a new token will need to be generated. This is handled automatically when you use a client like <code>kubectl</code>, however, if you're using the Kubernetes dashboard, you will need to generate a new token and re-authenticate each time the token expires. </p>
<p>Once the user's identity has been authenticated by the AWS IAM service, the kube-apiserver reads the <code>aws-auth</code> ConfigMap in the <code>kube-system</code> namespace to determine the RBAC group to associate with the user.  The <code>aws-auth</code> ConfigMap is used to create a static mapping betweeen IAM principles, i.e. IAM Users and Roles, and Kubernetes RBAC groups. RBAC groups can be referenced in Kubernetes RoleBindings or ClusterRoleBindings. They are similar to IAM Roles in that they define a set of actions (verbs) that can be peformed against a collection of Kubernetes resources (objects).</p>
<h3 id="recommendations">Recommendations<a class="headerlink" href="#recommendations" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p><strong>Don't use a service account token for authentication</strong>. A service account token is a long-lived, static, credential. If it is compromised, lost, or stolen, an attacker may be able to perform all the actions associated with that token until the service account is deleted. At times, you may need to grant an exception for applications that have to consume the Kubernetes API from outside the cluster, e.g. a CI/CD pipeline application. If such applications run on AWS infrastructure, like EC2 instances, consider using an instance profile and mapping that to a Kubernetes RBAC role in the <code>aws-auth</code> ConfigMap instead.  </p>
</li>
<li>
<p><strong>Employ least privileged access to AWS Resources</strong>. An IAM User does not need to be assigned privileges to AWS resources to access the Kubernetes API. If you need to grant an IAM user access to an EKS cluster, create an entry in the <code>aws-auth</code> ConfigMap for that user that maps to a specific Kubernetes RBAC group. </p>
</li>
<li>
<p><strong>Use IAM Roles when multiple users need identical access to the cluster</strong>. Rather than creating an entry for each individual IAM User in the <code>aws-auth</code> ConfigMap, allow those users to assume an IAM Role and map that role to a Kubernetes RBAC group.  This will be easier to maintain, especially as the number of users that require access grows.</p>
</li>
<li>
<p><strong>Employ least privilieged access when creating RoleBindings and ClusterRoleBindings</strong>. Like the earlier point about granting access to AWS Resources, RoleBindings and ClusterRoleBindings should only include the set of permissions necessary to perform a specific function. Avoid using <code>["*"]</code> in your Roles and ClusterRoles unless it's absolutely necessary. If you're unsure what permissions to assign, consider using a tool like <a href="https://github.com/liggitt/audit2rbac">audit2rbac</a> to automatically generate Roles and binding based on the observed API calls in the Kubernetes Audit Log.</p>
</li>
<li>
<p><strong>Regularly audit access to the cluster</strong>. Who requires access is likely to change over time. Plan to periodically audit the <code>aws-auth</code> ConfigMap to see who has been granted access and the rights they've been assigned. You can also use open source tooling like <a href="https://github.com/aquasecurity/kubectl-who-can">kubectl-who-can</a>, or <a href="https://github.com/FairwindsOps/rbac-lookup">rbac-lookup</a> to examine the roles bound to a particular service account, user, or group. We'll explore this topic further when we get to the section on <a href="../detective/">auditing</a>.  Additional ideas can be found in this <a href="https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2019/august/tools-and-methods-for-auditing-kubernetes-rbac-policies/?mkt_tok=eyJpIjoiWWpGa056SXlNV1E0WWpRNSIsInQiOiJBT1hyUTRHYkg1TGxBV0hTZnRibDAyRUZ0VzBxbndnRzNGbTAxZzI0WmFHckJJbWlKdE5WWDdUQlBrYVZpMnNuTFJ1R3hacVYrRCsxYWQ2RTRcL2pMN1BtRVA1ZFZcL0NtaEtIUDdZV3pENzNLcE1zWGVwUndEXC9Pb2tmSERcL1pUaGUifQ%3D%3D">article</a> from nccgroup. </p>
</li>
<li>
<p><strong>Make the EKS Cluster Endpoint private</strong>. By default when you provision an EKS cluster, the API cluster endpoint is set to public, i.e. it can be accessed from the Internet. Despite being accessible from the Internet, the endpoint is still considered secure because it requires all API requests to be authenticated by IAM and then authorized by Kubernetes RBAC. That said, if your corporate security policy mandates that you restrict access to the API from the Internet or prevents you from routing traffic outside the cluster VPC, you can: </p>
<ul>
<li>Configure the EKS cluster endpoint to be private. See <a href="https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html">Modifying Cluster Endpoint Access</a> for further information on this topic. </li>
<li>Leave the cluster endpoint public and specify which CIDR blocks can communicate with the cluster endpoint. The blocks are effectively a whitelisted set of public IP addresses that are allowed to access the cluster endpoint.</li>
<li>Configure public access with a set of whitelisted CIDR blocks and set private endpoint access to enabled. This will allow public access from a specific range of public IPs while forcing all network traffic between the kubelets (workers) and the Kubernetes API through the cross-account ENIs that get provisioned into the cluster VPC when the control plane is provisioned.</li>
</ul>
</li>
</ul>
<h3 id="alternative-approaches-to-authentication-and-access-management">Alternative Approaches to Authentication and Access Management<a class="headerlink" href="#alternative-approaches-to-authentication-and-access-management" title="Permanent link">&para;</a></h3>
<p>While IAM is the preferred way to authenticate users who need access to an EKS cluster, it is possible to use an OIDC identity provider such as GitHub using an authentication proxy and Kubernetes <a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation">impersonation</a>. Posts for 2 such solutions have been published on the AWS Open Source blog:</p>
<ul>
<li><a href="https://aws.amazon.com/blogs/opensource/authenticating-eks-github-credentials-teleport/">Authenticating to EKS Using GitHub Credentials with Teleport</a></li>
<li><a href="https://aws.amazon.com/blogs/opensource/consistent-oidc-authentication-across-multiple-eks-clusters-using-kube-oidc-proxy/">Consistent OIDC authentication across multiple EKS clusters using kube-oidc-proxy</a></li>
</ul>
<p>You can also use <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/what-is.html">AWS SSO</a> to federate AWS with an external identity provider, e.g. Azure AD. If you decide to use this, the AWS CLI v2.0 includes an option to create a named profile that makes it easy to associate an SSO session with your current CLI session and assume an IAM role. Know that you must assume a role prior to running <code>kubectl</code> as the IAM role is used to determine the user's Kubernetes RBAC group.</p>
<h2 id="pods-identities">Pods Identities<a class="headerlink" href="#pods-identities" title="Permanent link">&para;</a></h2>
<p>Certain applications that run within a Kubernetes cluster need permission to call the Kubernetes API to function properly. For example, the ALB Ingress Controller needs to be able to list a service's endpoints. The controller also needs to be able to invoke AWS APIs to provision and configure an ALB.  In this section we will explore the best practices for assigning rights and privileges to pods. </p>
<h3 id="kubernetes-service-accounts">Kubernetes Service Accounts<a class="headerlink" href="#kubernetes-service-accounts" title="Permanent link">&para;</a></h3>
<p>A service account is a special type of object that allows you to assign a Kubernetes RBAC role to a pod.  A default service account is created automatically for each namespace within a cluster. When you deploy a pod into a namespace without referencing a specific service account, the default service account for that namespace will automatically get assigned to the pod and the secret, i.e. the service account (JWT) token for that service account, will get mounted to the pod as a volume at <code>/var/run/secrets/kubernetes.io/serviceaccount</code>. Decoding the service account token in that directory will reveal the following metadata: </p>
<pre><code class="json">{
  &quot;iss&quot;: &quot;kubernetes/serviceaccount&quot;,
  &quot;kubernetes.io/serviceaccount/namespace&quot;: &quot;default&quot;,
  &quot;kubernetes.io/serviceaccount/secret.name&quot;: &quot;default-token-5pv4z&quot;,
  &quot;kubernetes.io/serviceaccount/service-account.name&quot;: &quot;default&quot;,
  &quot;kubernetes.io/serviceaccount/service-account.uid&quot;: &quot;3b36ddb5-438c-11ea-9438-063a49b60fba&quot;,
  &quot;sub&quot;: &quot;system:serviceaccount:default:default&quot;
}
</code></pre>

<p>The default service account has the following permissions to the Kubernetes API.</p>
<pre><code class="yaml">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;
  creationTimestamp: &quot;2020-01-30T18:13:25Z&quot;
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: system:discovery
  resourceVersion: &quot;43&quot;
  selfLink: /apis/rbac.authorization.k8s.io/v1/clusterroles/system%3Adiscovery
  uid: 350d2ab8-438c-11ea-9438-063a49b60fba
rules:
- nonResourceURLs:
  - /api
  - /api/*
  - /apis
  - /apis/*
  - /healthz
  - /openapi
  - /openapi/*
  - /version
  - /version/
  verbs:
  - get
</code></pre>

<p>This role authorizes unauthenticated and authenticated users to read API information and is deemed safe to be publicly accessible.</p>
<p>When an application running within a pod calls the Kubernetes APIs, the pod needs to be assigned a service account that grants it permission to do so.  Similar to guidelines for user access, the Role or ClusterRole bound to a service account should be restricted to the API resources and methods that the application needs to function and nothing else. To use a non-default service account simply set the <code>spec.serviceAccountName</code> field of a pod to the name of the service account you wish to use. For additional information about creating service accounts, see https://kubernetes.io/docs/reference/access-authn-authz/rbac/#service-account-permissions. </p>
<h3 id="iam-roles-for-service-accounts-irsa">IAM Roles for Service Accounts (IRSA)<a class="headerlink" href="#iam-roles-for-service-accounts-irsa" title="Permanent link">&para;</a></h3>
<p>IRSA is a new feature that allows you to assign an IAM role to a Kubernetes service account. It works by leveraging a Kubernetes feature known as <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection">Service Account Token Volume Projection</a>. Pods with service accounts that reference an IAM Role call a public OIDC discovery endpoint for AWS IAM upon startup. The endpoint cyrptographically signs the OIDC token issued by Kubernetes which ultimately allows the pod to call the AWS APIs associated IAM role. When an AWS API is invoked, the AWS SDKs calls <code>sts:AssumeRoleWithWebIdentity</code> and automatically exchanges the Kubernetes issued token for a AWS role credential. </p>
<p>Decoding the (JWT) token for IRSA will produce output similar to the example you see below: </p>
<pre><code class="json">{
  &quot;aud&quot;: [
    &quot;sts.amazonaws.com&quot;
  ],
  &quot;exp&quot;: 1582306514,
  &quot;iat&quot;: 1582220114,
  &quot;iss&quot;: &quot;https://oidc.eks.us-west-2.amazonaws.com/id/D43CF17C27A865987144EA99A26FB128&quot;,
  &quot;kubernetes.io&quot;: {
    &quot;namespace&quot;: &quot;default&quot;,
    &quot;pod&quot;: {
      &quot;name&quot;: &quot;alpine-57b5664646-rf966&quot;,
      &quot;uid&quot;: &quot;5a20f883-5407-11ea-a85c-0e62b7a4a436&quot;
    },
    &quot;serviceaccount&quot;: {
      &quot;name&quot;: &quot;s3-read-only&quot;,
      &quot;uid&quot;: &quot;a720ba5c-5406-11ea-9438-063a49b60fba&quot;
    }
  },
  &quot;nbf&quot;: 1582220114,
  &quot;sub&quot;: &quot;system:serviceaccount:default:s3-read-only&quot;
}
</code></pre>

<p>This particular token grants the pod view-only privileges to S3. When the application attempt to read from S3, the token is exchanged for a temporary set of IAM credentials that resembles this: </p>
<pre><code class="json">{
    &quot;AssumedRoleUser&quot;: {
        &quot;AssumedRoleId&quot;: &quot;AROA36C6WWEJULFUYMPB6:abc&quot;, 
        &quot;Arn&quot;: &quot;arn:aws:sts::820537372947:assumed-role/eksctl-winterfell-addon-iamserviceaccount-de-Role1-1D61LT75JH3MB/abc&quot;
    }, 
    &quot;Audience&quot;: &quot;sts.amazonaws.com&quot;, 
    &quot;Provider&quot;: &quot;arn:aws:iam::820537372947:oidc-provider/oidc.eks.us-west-2.amazonaws.com/id/D43CF17C27A865987144EA99A26FB128&quot;, 
    &quot;SubjectFromWebIdentityToken&quot;: &quot;system:serviceaccount:default:s3-read-only&quot;, 
    &quot;Credentials&quot;: {
        &quot;SecretAccessKey&quot;: &quot;ORJ+8Adk+wW+nU8FETq7+mOqeA8Z6jlPihnV8hX1&quot;, 
        &quot;SessionToken&quot;: &quot;FwoGZXIvYXdzEGMaDMLxAZkuLpmSwYXShiL9A1S0X87VBC1mHCrRe/pB2oes+l1eXxUYnPJyC9ayOoXMvqXQsomq0xs6OqZ3vaa5Iw1HIyA4Cv1suLaOCoU3hNvOIJ6C94H1vU0siQYk7DIq9Av5RZe+uE2FnOctNBvYLd3i0IZo1ajjc00yRK3v24VRq9nQpoPLuqyH2jzlhCEjXuPScPbi5KEVs9fNcOTtgzbVf7IG2gNiwNs5aCpN4Bv/Zv2A6zp5xGz9cWj2f0aD9v66vX4bexOs5t/YYhwuwAvkkJPSIGvxja0xRThnceHyFHKtj0H+bi/PWAtlI8YJcDX69cM30JAHDdQH+ltm/4scFptW1hlvMaP+WReCAaCrsHrAT+yka7ttw5YlUyvZ8EPog+j6fwHlxmrXM9h1BqdikomyJU00gm1++FJelfP+1zAwcyrxCnbRl3ARFrAt8hIlrT6Vyu8WvWtLxcI8KcLcJQb/LgkW+sCTGlYcY8z3zkigJMbYn07ewTL5Ss7LazTJJa758I7PZan/v3xQHd5DEc5WBneiV3iOznDFgup0VAMkIviVjVCkszaPSVEdK2NU7jtrh6Jfm7bU/3P6ZG+CkyDLIa8MBn9KPXeJd/y+jTk5Ii+fIwO/+mDpGNUribg6TPxhzZ8b/XdZO1kS1gVgqjXyVC+M+BRBh6C4H21w/eMzjCtDIpoxt5rGKL6Nu/IFMipoC4fgx6LIIHwtGYMG7SWQi7OsMAkiwZRg0n68/RqWgLzBt/4pfjSRYuk=&quot;, 
        &quot;Expiration&quot;: &quot;2020-02-20T18:49:50Z&quot;, 
        &quot;AccessKeyId&quot;: &quot;ASIA36C6WWEJUMHA3L7Z&quot;
    }
}
</code></pre>

<p>A mutating webhook that runs as part of the EKS control plane injects the AWS Role Arn and the path to a web identity token file into the pod as environment variables. These values can also be supplied manually. </p>
<pre><code>AWS_ROLE_ARN=arn:aws:iam::AWS_ACCOUNT_ID:role/IAM_ROLE_NAME
AWS_WEB_IDENTITY_TOKEN_FILE=/var/run/secrets/eks.amazonaws.com/serviceaccount/token
</code></pre>

<p>The kubelet will automatically rotate the projected token when it is older than 80% of its total TTL, or after 24 hours. The AWS SDKs are responsible for reloading the token when it rotates. For further information about IRSA, see https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts-technical-overview.html.</p>
<h3 id="recommendations_1">Recommendations<a class="headerlink" href="#recommendations_1" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p><strong>Disable auto-mounting of service account tokens</strong>. If your application doesn't need to call the Kubernetes API set the <code>automountServiceAccountToken</code> attribute to <code>false</code> in the PodSec for your application or patch the default service account in each namespace so that it's no longer mounted to pods automatically. For example: 
    <code>kubectl patch serviceaccount default -p $'automountServiceAccountToken: false'</code></p>
</li>
<li>
<p><strong>Use dedicated service accounts for each application</strong>. Each application should have its own dedicated service account.  This applies to service accounts for the Kubernetes API as well as IRSA. </p>
<p>If you employ a blue/green approach to cluster upgrades instead of performing an in-place cluster upgrade, you will need to update the trust policy of each of the IRSA IAM roles with the OIDC endpoint of the new cluster. A blue/green cluster upgrade is where you create a cluster running a newer version of Kubernetes alongside the old cluster and use a load balancer or a service mesh to seamlessly shift traffic from services running on the old cluster to the new cluster. </p>
</li>
<li>
<p><strong>Restrict access to the instance profile assigned to the worker node</strong>. When you use IRSA, the pod no longer inherits the rights of the instance profile assigned to the worker node. Nonetheless, as an added precaution, you may want to block a process's ability to access EC2 metadata. This will effectively prevent pods that do not use IRSA from inheriting the role assigned to the worker node. Be aware that when you block access to EC2 metadata on a worker node, it may prevent certain pods from functioning properly. For additional information about how to block access to instance metadata, see https://docs.aws.amazon.com/eks/latest/userguide/restrict-ec2-credential-access.html.</p>
</li>
<li>
<p><strong>Run the application as a non-root user</strong>. Containers run as root by default. While this allows them to to read the web identity token file, running a container as root is not considered a best practice. As an alternative, consider adding the <code>spec.securityContext.runAsUser</code> attribute to the PodSpec.  The value of <code>runAsUser</code> is abritrary value.   </p>
</li>
<li>
<p><strong>Scope the IAM Role trust policy for IRSA to the service account name</strong>. The trust policy can be scoped to a namespace or a specific service account within a namespace. When using IRSA it's best to make the role trust policy as explicit as possible by including the service account name. This will effectively prevent other pods within the same namespace from assuming the role. The CLI <code>eksctl</code> will do this automatically when you use it to create service accounts/IAM roles. See https://eksctl.io/usage/iamserviceaccounts/ for futher information. </p>
</li>
</ul>
<h4 id="alternative-approaches">Alternative approaches<a class="headerlink" href="#alternative-approaches" title="Permanent link">&para;</a></h4>
<p>While IRSA is the <em>preferred way</em> to assign an AWS "identity" to a pod, it requires that you include recent version of the AWS SDKs in your application. For a complete listing of the SDKs that currently support IRSA, see https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts-minimum-sdk.html. If you have an application that you can't immediately update with a IRSA-compatible SDK, there are several community-built solutions available for assigning IAM roles to Kubernetes pods, including <a href="https://github.com/jtblin/kube2iam">kube2iam</a> and <a href="https://github.com/uswitch/kiam">kiam</a>.  Although AWS doesn't endorse or condone the use of these solutions, they are frequently used by the community at large to achieve similar results as IRSA. </p>


</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">

<h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
<ul class="search-results-list"></ul>

</div> <!-- end of has-results -->
<div class="no-results">

<h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>

</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../js/main.js"></script>
<script src="../search/main.js"></script>
<script src="../js/gitbook.min.js"></script>
<script src="../js/theme.min.js"></script>
</body>
</html>